# Story 2.5: Geographic Aggregation API

## Status

Approved

## Story

**As a** regional manager,
**I want** to view pricing data aggregated by geographic regions,
**so that** I can understand market dynamics across areas.

## Acceptance Criteria

1. GET /api/v1/geo/estados returns average prices grouped by estado (state)
2. GET /api/v1/geo/municipios/{estado} returns average prices for all municipios in a state
3. GET /api/v1/geo/stats/{municipio} returns detailed statistics for specific municipio
4. Endpoints include station count, price ranges, and top/bottom performers
5. Support for comparison between multiple geographic areas
6. Heat map data structure for visualization of geographic price variations

## Tasks / Subtasks

- [ ] **Task 1: Create GeoController** (AC: 1, 2, 3)
  - [ ] Create GeoController in app/Http/Controllers/Api/
  - [ ] Add routes to routes/api/v1.php
  - [ ] Apply authentication middleware
  - [ ] Set up dependency injection for services
  - [ ] Configure response formatting

- [ ] **Task 2: Build GeographicRepository** (AC: 1, 2, 3, 4)
  - [ ] Create repository for geographic queries
  - [ ] Implement getEstadoAggregates() method
  - [ ] Create getMunicipiosByEstado() method
  - [ ] Build getMunicipioStats() method
  - [ ] Optimize queries with proper indexing

- [ ] **Task 3: Implement estados aggregation endpoint** (AC: 1, 4)
  - [ ] Query average prices by estado
  - [ ] Calculate min/max prices per estado
  - [ ] Count active stations per estado
  - [ ] Include price variance metrics
  - [ ] Sort by configurable criteria

- [ ] **Task 4: Create municipios by estado endpoint** (AC: 2, 4)
  - [ ] Validate estado parameter exists
  - [ ] Aggregate prices by municipio
  - [ ] Include station density metrics
  - [ ] Calculate price competitiveness index
  - [ ] Add pagination for large estados

- [ ] **Task 5: Build municipio statistics endpoint** (AC: 3, 4)
  - [ ] Validate municipio exists
  - [ ] Calculate comprehensive statistics
  - [ ] Identify top/bottom performing stations
  - [ ] Include historical comparison (vs last week)
  - [ ] Generate price distribution histogram data

- [ ] **Task 6: Implement GeographicComparisonService** (AC: 5)
  - [ ] Accept multiple geographic areas
  - [ ] Calculate comparative metrics
  - [ ] Generate difference matrices
  - [ ] Compute competitiveness scores
  - [ ] Rank areas by price levels

- [ ] **Task 7: Add comparison endpoints** (AC: 5)
  - [ ] Create POST /api/v1/geo/compare endpoint
  - [ ] Accept array of geographic identifiers
  - [ ] Support mixed comparisons (estados vs municipios)
  - [ ] Calculate relative price indices
  - [ ] Include population/density weighting

- [ ] **Task 8: Create HeatMapDataService** (AC: 6)
  - [ ] Generate grid-based heat map data
  - [ ] Interpolate prices for sparse areas
  - [ ] Create zoom level aggregations
  - [ ] Format for map visualization libraries
  - [ ] Include gradient color calculations

- [ ] **Task 9: Build heat map endpoint** (AC: 6)
  - [ ] Create GET /api/v1/geo/heatmap endpoint
  - [ ] Accept bounding box parameters
  - [ ] Support multiple zoom levels
  - [ ] Cache heat map tiles
  - [ ] Optimize for frontend rendering

- [ ] **Task 10: Implement performance analysis** (AC: 4)
  - [ ] Identify price leaders/laggards
  - [ ] Calculate market efficiency scores
  - [ ] Detect pricing anomalies
  - [ ] Generate regional insights
  - [ ] Track pricing trends by region

- [ ] **Task 11: Add caching and optimization** (AC: All)
  - [ ] Cache geographic aggregations (30-min TTL)
  - [ ] Create materialized views for common queries
  - [ ] Implement query result pagination
  - [ ] Use database partitioning if needed
  - [ ] Monitor query performance

## Dev Notes

### Previous Story Context

[Source: Stories 1.2, 2.2, 2.3, 2.4]

- Story 1.2: entidades and municipios tables with geographic data
- Story 2.2: Current pricing with location data
- Story 2.3: Historical trends with market aggregation
- Story 2.4: Competitor analysis with geographic filtering

### Geographic Data Model

[Source: Story 1.2, architecture/database-schema.md]

**Geographic Hierarchy:**

```
País (Mexico)
└── Estado (32 estados)
    └── Municipio (2,457 municipios)
        └── Station (5,000+ stations)
```

### Estado Aggregation Query

[Source: AC 1, 4]

```sql
WITH estado_prices AS (
  SELECT
    e.id as estado_id,
    e.nombre as estado_nombre,
    e.codigo as estado_codigo,
    pc.fuel_type,
    AVG(pc.price) as avg_price,
    MIN(pc.price) as min_price,
    MAX(pc.price) as max_price,
    STDDEV(pc.price) as price_stddev,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY pc.price) as median_price,
    COUNT(DISTINCT s.numero) as station_count,
    COUNT(*) as sample_size
  FROM entidades e
  JOIN stations s ON s.entidad_id = e.id
  JOIN LATERAL (
    SELECT DISTINCT ON (station_numero, fuel_type)
      station_numero,
      fuel_type,
      price,
      changed_at
    FROM price_changes
    WHERE changed_at >= NOW() - INTERVAL '24 hours'
    ORDER BY station_numero, fuel_type, changed_at DESC
  ) pc ON pc.station_numero = s.numero
  WHERE s.is_active = true
  GROUP BY e.id, e.nombre, e.codigo, pc.fuel_type
)
SELECT
  estado_id,
  estado_nombre,
  estado_codigo,
  json_object_agg(
    fuel_type,
    json_build_object(
      'avg', ROUND(avg_price, 2),
      'min', min_price,
      'max', max_price,
      'median', ROUND(median_price, 2),
      'stddev', ROUND(price_stddev, 2),
      'spread', ROUND(max_price - min_price, 2),
      'station_count', station_count
    )
  ) as fuel_prices,
  SUM(station_count) / 3 as total_stations -- Divided by fuel types
FROM estado_prices
GROUP BY estado_id, estado_nombre, estado_codigo
ORDER BY estado_nombre;
```

### Municipio Statistics Query

[Source: AC 3, 4]

```sql
WITH municipio_stats AS (
  SELECT
    m.id,
    m.nombre,
    s.numero,
    s.nombre as station_nombre,
    s.brand,
    pc.fuel_type,
    pc.price,
    pc.changed_at,
    AVG(pc.price) OVER (PARTITION BY m.id, pc.fuel_type) as municipio_avg,
    RANK() OVER (PARTITION BY m.id, pc.fuel_type ORDER BY pc.price ASC) as price_rank_asc,
    RANK() OVER (PARTITION BY m.id, pc.fuel_type ORDER BY pc.price DESC) as price_rank_desc
  FROM municipios m
  JOIN stations s ON s.municipio_id = m.id
  JOIN LATERAL (
    SELECT DISTINCT ON (station_numero, fuel_type)
      station_numero,
      fuel_type,
      price,
      changed_at
    FROM price_changes
    WHERE changed_at >= NOW() - INTERVAL '24 hours'
    ORDER BY station_numero, fuel_type, changed_at DESC
  ) pc ON pc.station_numero = s.numero
  WHERE m.id = :municipio_id
    AND s.is_active = true
)
SELECT
  id as municipio_id,
  nombre as municipio_nombre,
  fuel_type,
  json_build_object(
    'statistics', json_build_object(
      'avg', ROUND(AVG(price), 2),
      'min', MIN(price),
      'max', MAX(price),
      'median', PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY price),
      'stddev', ROUND(STDDEV(price), 2),
      'coefficient_variation', ROUND(STDDEV(price) / AVG(price) * 100, 2)
    ),
    'top_performers', (
      SELECT json_agg(json_build_object(
        'numero', numero,
        'nombre', station_nombre,
        'brand', brand,
        'price', price,
        'vs_avg', ROUND(price - municipio_avg, 2)
      ) ORDER BY price ASC)
      FROM municipio_stats ms2
      WHERE ms2.fuel_type = municipio_stats.fuel_type
        AND price_rank_asc <= 3
    ),
    'bottom_performers', (
      SELECT json_agg(json_build_object(
        'numero', numero,
        'nombre', station_nombre,
        'brand', brand,
        'price', price,
        'vs_avg', ROUND(price - municipio_avg, 2)
      ) ORDER BY price DESC)
      FROM municipio_stats ms3
      WHERE ms3.fuel_type = municipio_stats.fuel_type
        AND price_rank_desc <= 3
    ),
    'station_count', COUNT(DISTINCT numero),
    'last_update', MAX(changed_at)
  ) as data
FROM municipio_stats
GROUP BY id, nombre, fuel_type;
```

### Geographic Comparison Service

[Source: AC 5]

```php
// app/Services/GeographicComparisonService.php
class GeographicComparisonService
{
    public function compareAreas(array $areas)
    {
        $results = [];

        foreach ($areas as $area) {
            $stats = $this->getAreaStatistics($area);
            $results[$area['id']] = $stats;
        }

        // Calculate comparison matrix
        $comparison = $this->buildComparisonMatrix($results);

        // Generate insights
        $insights = $this->generateInsights($results);

        return [
            'areas' => $results,
            'comparison' => $comparison,
            'insights' => $insights,
            'rankings' => $this->rankAreas($results)
        ];
    }

    private function buildComparisonMatrix($results)
    {
        $matrix = [];
        $areaIds = array_keys($results);

        foreach ($areaIds as $fromId) {
            foreach ($areaIds as $toId) {
                if ($fromId === $toId) continue;

                foreach (['regular', 'premium', 'diesel'] as $fuel) {
                    $fromPrice = $results[$fromId][$fuel]['avg'];
                    $toPrice = $results[$toId][$fuel]['avg'];

                    $matrix[$fromId][$toId][$fuel] = [
                        'difference' => round($fromPrice - $toPrice, 2),
                        'percent' => round((($fromPrice - $toPrice) / $toPrice) * 100, 2),
                        'cheaper' => $fromPrice < $toPrice
                    ];
                }
            }
        }

        return $matrix;
    }

    private function generateInsights($results)
    {
        $insights = [];

        // Find cheapest/most expensive areas
        foreach (['regular', 'premium', 'diesel'] as $fuel) {
            $prices = array_map(fn($r) => $r[$fuel]['avg'], $results);
            $minArea = array_search(min($prices), $prices);
            $maxArea = array_search(max($prices), $prices);

            $insights[] = [
                'type' => 'price_leader',
                'fuel' => $fuel,
                'area' => $minArea,
                'message' => "Cheapest $fuel prices",
                'value' => min($prices)
            ];

            $insights[] = [
                'type' => 'price_laggard',
                'fuel' => $fuel,
                'area' => $maxArea,
                'message' => "Most expensive $fuel prices",
                'value' => max($prices)
            ];
        }

        // Calculate price disparity
        $disparities = [];
        foreach ($results as $areaId => $stats) {
            $spread = $stats['regular']['max'] - $stats['regular']['min'];
            $disparities[$areaId] = $spread;
        }

        $maxDisparity = max($disparities);
        $maxDisparityArea = array_search($maxDisparity, $disparities);

        $insights[] = [
            'type' => 'price_disparity',
            'area' => $maxDisparityArea,
            'message' => 'Highest price variation within area',
            'value' => $maxDisparity
        ];

        return $insights;
    }
}
```

### Heat Map Data Structure

[Source: AC 6]

```php
// app/Services/HeatMapDataService.php
class HeatMapDataService
{
    public function generateHeatMap($bounds, $zoomLevel)
    {
        // Calculate grid resolution based on zoom
        $gridSize = $this->calculateGridSize($zoomLevel);

        // Get stations with prices in bounds
        $stations = $this->getStationsInBounds($bounds);

        // Create grid cells
        $grid = $this->createGrid($bounds, $gridSize);

        // Interpolate prices for each cell
        foreach ($grid as &$cell) {
            $cell['prices'] = $this->interpolatePrices(
                $cell['center'],
                $stations
            );
            $cell['intensity'] = $this->calculateIntensity(
                $cell['prices']
            );
            $cell['color'] = $this->getColorGradient(
                $cell['intensity']
            );
        }

        return [
            'bounds' => $bounds,
            'zoom' => $zoomLevel,
            'grid_size' => $gridSize,
            'cells' => $grid,
            'legend' => $this->generateLegend(),
            'timestamp' => now()->toIso8601String()
        ];
    }

    private function interpolatePrices($point, $stations)
    {
        $weights = [];
        $weightedPrices = ['regular' => 0, 'premium' => 0, 'diesel' => 0];

        foreach ($stations as $station) {
            $distance = $this->haversineDistance(
                $point['lat'],
                $point['lng'],
                $station->lat,
                $station->lng
            );

            // Inverse distance weighting
            $weight = 1 / max($distance, 0.1); // Avoid division by zero
            $weights[] = $weight;

            foreach (['regular', 'premium', 'diesel'] as $fuel) {
                $price = $station->prices[$fuel] ?? 0;
                $weightedPrices[$fuel] += $price * $weight;
            }
        }

        $totalWeight = array_sum($weights);

        foreach ($weightedPrices as $fuel => &$price) {
            $price = $totalWeight > 0 ? $price / $totalWeight : 0;
        }

        return $weightedPrices;
    }

    private function getColorGradient($intensity)
    {
        // Green (cheap) -> Yellow (average) -> Red (expensive)
        $colors = [
            0 => ['r' => 0, 'g' => 255, 'b' => 0],      // Green
            50 => ['r' => 255, 'g' => 255, 'b' => 0],   // Yellow
            100 => ['r' => 255, 'g' => 0, 'b' => 0]     // Red
        ];

        // Linear interpolation between color stops
        if ($intensity <= 50) {
            $ratio = $intensity / 50;
            return $this->interpolateColor($colors[0], $colors[50], $ratio);
        } else {
            $ratio = ($intensity - 50) / 50;
            return $this->interpolateColor($colors[50], $colors[100], $ratio);
        }
    }
}
```

### API Response Formats

[Source: AC 1, 2, 3, 5, 6]

**GET /api/v1/geo/estados**

```json
{
  "data": [
    {
      "estado_id": 1,
      "estado_nombre": "CDMX",
      "estado_codigo": "CDMX",
      "fuel_prices": {
        "regular": {
          "avg": 23.12,
          "min": 22.45,
          "max": 23.89,
          "median": 23.1,
          "stddev": 0.34,
          "spread": 1.44,
          "station_count": 245
        },
        "premium": {
          "avg": 24.89,
          "min": 24.12,
          "max": 25.67,
          "median": 24.85,
          "stddev": 0.42,
          "spread": 1.55,
          "station_count": 245
        },
        "diesel": {
          "avg": 24.45,
          "min": 23.89,
          "max": 25.12,
          "median": 24.42,
          "stddev": 0.38,
          "spread": 1.23,
          "station_count": 245
        }
      },
      "total_stations": 245,
      "market_efficiency": 0.82,
      "last_update": "2024-01-13T10:00:00Z"
    }
  ],
  "summary": {
    "total_estados": 32,
    "national_average": {
      "regular": 22.89,
      "premium": 24.56,
      "diesel": 24.12
    },
    "cheapest_estado": "Chiapas",
    "most_expensive_estado": "Baja California Sur"
  }
}
```

**GET /api/v1/geo/stats/{municipio}**

```json
{
  "data": {
    "municipio": {
      "id": 123,
      "nombre": "Cuauhtémoc",
      "estado": "CDMX"
    },
    "statistics": {
      "regular": {
        "avg": 23.01,
        "min": 22.45,
        "max": 23.67,
        "median": 22.98,
        "stddev": 0.34,
        "coefficient_variation": 1.48,
        "top_performers": [
          {
            "numero": "12345",
            "nombre": "Pemex Centro",
            "brand": "Pemex",
            "price": 22.45,
            "vs_avg": -0.56
          }
        ],
        "bottom_performers": [
          {
            "numero": "12389",
            "nombre": "Shell Norte",
            "brand": "Shell",
            "price": 23.67,
            "vs_avg": 0.66
          }
        ],
        "station_count": 45,
        "price_distribution": {
          "22.00-22.50": 5,
          "22.50-23.00": 18,
          "23.00-23.50": 17,
          "23.50-24.00": 5
        }
      },
      "premium": {...},
      "diesel": {...}
    },
    "trends": {
      "vs_last_week": {
        "regular": 1.2,
        "premium": 0.8,
        "diesel": -0.3
      },
      "vs_estado_avg": {
        "regular": -0.11,
        "premium": 0.05,
        "diesel": -0.08
      }
    }
  }
}
```

**POST /api/v1/geo/compare**

```json
// Request
{
  "areas": [
    {"type": "estado", "id": 1},
    {"type": "municipio", "id": 123},
    {"type": "municipio", "id": 456}
  ],
  "fuel_types": ["regular", "premium", "diesel"]
}

// Response
{
  "data": {
    "comparison": {
      "estado_1": {
        "municipio_123": {
          "regular": {
            "difference": 0.11,
            "percent": 0.48,
            "cheaper": false
          }
        }
      }
    },
    "rankings": [
      {
        "position": 1,
        "area": "municipio_456",
        "name": "Tlalpan",
        "avg_price": 22.78,
        "score": 95.2
      }
    ],
    "insights": [
      {
        "type": "price_leader",
        "fuel": "regular",
        "area": "municipio_456",
        "message": "Cheapest regular prices",
        "value": 22.78
      }
    ]
  }
}
```

**GET /api/v1/geo/heatmap**

```json
{
  "data": {
    "bounds": {
      "north": 19.5,
      "south": 19.3,
      "east": -99.0,
      "west": -99.2
    },
    "zoom": 12,
    "grid_size": 0.01,
    "cells": [
      {
        "id": "cell_0_0",
        "center": { "lat": 19.495, "lng": -99.195 },
        "prices": {
          "regular": 22.89,
          "premium": 24.56,
          "diesel": 24.12
        },
        "intensity": 45.2,
        "color": "#FFCC00",
        "station_count": 3
      }
    ],
    "legend": {
      "min_price": 22.45,
      "max_price": 24.89,
      "color_scale": [
        { "value": 22.45, "color": "#00FF00" },
        { "value": 23.67, "color": "#FFFF00" },
        { "value": 24.89, "color": "#FF0000" }
      ]
    },
    "timestamp": "2024-01-13T10:00:00Z"
  }
}
```

### Caching Strategy

[Source: AC 11]

```php
// Geographic data changes infrequently, use longer TTL
$estadoCacheKey = 'geo:estados:' . md5(json_encode($filters));
$ttl = 1800; // 30 minutes

// Heat map tiles cached with zoom level
$heatmapCacheKey = sprintf(
    'geo:heatmap:%s:%s:%s:%s:%d',
    $bounds['north'],
    $bounds['south'],
    $bounds['east'],
    $bounds['west'],
    $zoomLevel
);

// Comparison results cached
$compareCacheKey = 'geo:compare:' . md5(json_encode($areas));
```

### Performance Optimizations

[Source: AC 11]

```sql
-- Materialized view for estado aggregations
CREATE MATERIALIZED VIEW estado_price_aggregates AS
SELECT
  e.id as estado_id,
  e.nombre as estado_nombre,
  pc.fuel_type,
  AVG(pc.price) as avg_price,
  MIN(pc.price) as min_price,
  MAX(pc.price) as max_price,
  STDDEV(pc.price) as stddev_price,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY pc.price) as median_price,
  COUNT(DISTINCT s.numero) as station_count,
  MAX(pc.changed_at) as last_update
FROM entidades e
JOIN stations s ON s.entidad_id = e.id
JOIN LATERAL (
  SELECT DISTINCT ON (station_numero, fuel_type)
    station_numero,
    fuel_type,
    price,
    changed_at
  FROM price_changes
  WHERE changed_at >= CURRENT_DATE - INTERVAL '1 day'
  ORDER BY station_numero, fuel_type, changed_at DESC
) pc ON pc.station_numero = s.numero
WHERE s.is_active = true
GROUP BY e.id, e.nombre, pc.fuel_type;

CREATE INDEX idx_estado_aggregates ON estado_price_aggregates(estado_id, fuel_type);

-- Refresh hourly
REFRESH MATERIALIZED VIEW CONCURRENTLY estado_price_aggregates;
```

## Testing

### Testing Standards

[Source: architecture/testing-strategy.md]

- Feature tests for all geographic endpoints
- Unit tests for aggregation calculations
- Performance tests for large datasets
- Test heat map generation accuracy

### Specific Test Cases

1. Estado aggregation returns all 32 states
2. Municipio statistics include top/bottom performers
3. Geographic comparison handles mixed types
4. Heat map interpolation is mathematically correct
5. Color gradient calculation works properly
6. Caching reduces query load
7. Materialized views update correctly
8. Pagination works for large estados
9. Price distribution histograms are accurate
10. Market efficiency scores calculated correctly
11. Insights generation identifies correct patterns
12. API responds within acceptable time for large queries

## Change Log

| Date       | Version | Description            | Author      |
| ---------- | ------- | ---------------------- | ----------- |
| 2025-08-13 | 1.0     | Initial story creation | BMad Master |

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Debug Log References

(To be filled by dev agent)

### Completion Notes List

(To be filled by dev agent)

### File List

(To be filled by dev agent)

## QA Results

(To be filled by QA agent)
