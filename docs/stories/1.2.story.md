# Story 1.2: Database Schema Design

## Status

Approved

## Story

**As a** system architect,
**I want** to design and implement an efficient PostgreSQL schema for permanent price storage,
**so that** we can track all price changes over time without redundant data.

## Acceptance Criteria

1. Database migrations create geographic tables: entidades (id, nombre matching EntidadFederativaId structure), municipios (id, entidad_id, nombre), and stations (numero as primary key, nombre, direccion, lat, lng, entidad_id, municipio_id)
2. Price_changes table stores only changes with columns (station_numero, fuel_type with CHECK constraint for ['diesel', 'premium', 'regular'], subproducto text for full fuel description, price decimal(5,2), changed_at timestamp, created_at)
3. User management tables created: users (uuid id, email, name, password, telegram_chat_id, subscription_tier), user_stations (user_id, station_numero, role), and api_tokens for service authentication
4. Alert system tables created: alerts (uuid id, user_id, name, type, conditions JSON, is_active) and alert_notifications (history tracking)
5. Scraper tracking table created: scraper_runs (id, started_at, completed_at, status, statistics columns, errors JSON)
6. Proper indexes on all foreign keys, commonly queried fields, and composite indexes for performance
7. Foreign key constraints ensure referential integrity across all table relationships
8. Fuel type mapping logic standardizes SubProducto variations to 'regular', 'premium', or 'diesel'
9. Migration includes initial data load for all 32 entidades and their municipios from the catalog API

## Tasks / Subtasks

- [ ] **Task 1: Create initial database migrations structure** (AC: 1)
  - [ ] Set up Laravel migrations directory structure
  - [ ] Create migration for entidades table
  - [ ] Create migration for municipios table with foreign key to entidades
  - [ ] Create migration for stations table with foreign keys to entidades and municipios

- [ ] **Task 2: Implement price tracking schema** (AC: 2, 3)
  - [ ] Create migration for price_changes table with change-only storage pattern
  - [ ] Define fuel_type enum with values ('regular', 'premium', 'diesel')
  - [ ] Add proper decimal precision for price field (5,2)
  - [ ] Implement timestamp fields for changed_at and detected_at

- [ ] **Task 3: Configure database indexes** (AC: 3)
  - [ ] Add index on stations.entidad_id and stations.municipio_id
  - [ ] Add composite index on stations (lat, lng) for geo queries
  - [ ] Add index on price_changes.station_numero
  - [ ] Add index on price_changes.changed_at for time-based queries
  - [ ] Add composite index on price_changes (station_numero, fuel_type, changed_at DESC)

- [ ] **Task 4: Implement user and authentication tables** (AC: 3)
  - [ ] Create migration for users table with UUID primary key
  - [ ] Create migration for user_stations junction table
  - [ ] Create migration for api_tokens table for service authentication
  - [ ] Add proper foreign key constraints with CASCADE options

- [ ] **Task 5: Create alert and notification tables** (AC: 4)
  - [ ] Create migration for alerts table with JSONB conditions field
  - [ ] Create migration for alert_notifications history table
  - [ ] Add foreign key relationships to users table
  - [ ] Configure proper indexes for query performance

- [ ] **Task 6: Implement scraper tracking table** (AC: 5)
  - [ ] Create migration for scraper_runs table
  - [ ] Add columns for tracking statistics (estados_processed, stations_found, etc.)
  - [ ] Add JSONB field for error logging
  - [ ] Create indexes for run history queries

- [ ] **Task 7: Create fuel type mapping helper** (AC: 8)
  - [ ] Create PHP helper class for SubProducto to fuel_type mapping
  - [ ] Implement mapping logic for Regular variants
  - [ ] Implement mapping logic for Premium variants
  - [ ] Implement mapping logic for Diesel variants
  - [ ] Add unit tests for all mapping scenarios

- [ ] **Task 8: Create database seeders** (AC: 9)
  - [ ] Create seeder to fetch and load all 32 Mexican states from government API
  - [ ] Create seeder to fetch and load municipalities for each state
  - [ ] Handle API failures gracefully with retry logic
  - [ ] Create command to run initial data load: `php artisan db:seed --class=LocationSeeder`

- [ ] **Task 9: Implement PostgreSQL-specific features** (AC: 1, 2, 3, 4, 5)
  - [ ] Configure Laravel for PostgreSQL connection
  - [ ] Ensure migrations use PostgreSQL syntax (not MySQL)
  - [ ] Set up proper timestamp handling with timezone support
  - [ ] Configure UUID generation for users and alerts tables

- [ ] **Task 10: Verify database integrity** (AC: 7)
  - [ ] Test all foreign key constraints work correctly
  - [ ] Verify CASCADE delete operations function as expected
  - [ ] Test unique constraints on appropriate fields
  - [ ] Ensure all indexes are created successfully

- [ ] **Task 11: Create database documentation** (AC: 1-9)
  - [ ] Document the change-only storage pattern for price data
  - [ ] Create ER diagram showing table relationships
  - [ ] Document fuel type mapping logic with examples
  - [ ] Add migration rollback procedures

## Dev Notes

### Previous Story Context

[Source: Story 1.1]
Story 1.1 established the monorepo structure with Docker configuration including PostgreSQL 15+ service. The database connection parameters are configured in the Laravel .env file with:

- DB_CONNECTION=pgsql
- DB_HOST, DB_PORT, DB_DATABASE, DB_USERNAME, DB_PASSWORD

### Database Schema Specification

[Source: architecture/database-schema.md]

**Complete Tables Structure (All 9 tables):**

1. **entidades table** (Mexican states):
   - id: INTEGER PRIMARY KEY (government-assigned ID)
   - nombre: VARCHAR(100) NOT NULL
   - codigo: VARCHAR(10) (state code like 'CDMX')

2. **municipios table** (Municipalities):
   - id: INTEGER PRIMARY KEY
   - entidad_id: INTEGER NOT NULL (FK to entidades)
   - nombre: VARCHAR(150) NOT NULL
   - INDEX idx_entidad on entidad_id

3. **stations table** (Gas stations):
   - numero: VARCHAR(50) PRIMARY KEY (government permit number)
   - nombre: VARCHAR(255) NOT NULL
   - direccion: TEXT
   - lat: DECIMAL(10, 8)
   - lng: DECIMAL(11, 8)
   - entidad_id: INTEGER NOT NULL (FK)
   - municipio_id: INTEGER NOT NULL (FK)
   - brand: VARCHAR(50) (optional)
   - is_active: BOOLEAN DEFAULT true
   - Indexes: idx_location (entidad_id, municipio_id), idx_coords (lat, lng)

4. **price_changes table** (Change-only storage):
   - id: BIGSERIAL PRIMARY KEY
   - station_numero: VARCHAR(50) NOT NULL (FK to stations)
   - fuel_type: VARCHAR(10) with CHECK constraint ('regular', 'premium', 'diesel')
   - subproducto: TEXT (original government description)
   - price: DECIMAL(5,2) NOT NULL
   - changed_at: TIMESTAMP NOT NULL (when price actually changed)
   - detected_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   - Indexes: idx_station_fuel, idx_changed, idx_station_fuel_changed (composite)

5. **users table** (Platform users):
   - id: UUID PRIMARY KEY (use gen_random_uuid() or Laravel's Str::uuid())
   - email: VARCHAR(255) UNIQUE NOT NULL
   - name: VARCHAR(255) NOT NULL
   - password: VARCHAR(255) NOT NULL
   - telegram_chat_id: VARCHAR(50) UNIQUE (nullable)
   - subscription_tier: VARCHAR(10) CHECK IN ('free', 'basic', 'premium')
   - notification_preferences: JSONB
   - api_rate_limit: INTEGER DEFAULT 100
   - email_verified_at: TIMESTAMP NULL
   - Indexes: idx_email, idx_telegram

6. **user_stations table** (User-Station relationship):
   - user_id: UUID PRIMARY KEY (FK to users)
   - station_numero: VARCHAR(50) NOT NULL (FK to stations)
   - role: VARCHAR(10) CHECK IN ('owner', 'manager', 'viewer')
   - created_at: TIMESTAMP

7. **alerts table** (User alert configurations):
   - id: UUID PRIMARY KEY
   - user_id: UUID NOT NULL (FK to users)
   - name: VARCHAR(255) NOT NULL
   - type: VARCHAR(20) CHECK IN ('price_change', 'competitor_move', 'market_trend')
   - conditions: JSONB NOT NULL
   - is_active: BOOLEAN DEFAULT true
   - last_triggered_at: TIMESTAMP NULL
   - Index: idx_user_active (user_id, is_active)

8. **alert_notifications table** (Alert history):
   - id: BIGSERIAL PRIMARY KEY
   - alert_id: UUID NOT NULL (FK to alerts)
   - triggered_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   - channel: VARCHAR(10) CHECK IN ('telegram', 'email', 'web')
   - delivered: BOOLEAN DEFAULT false
   - content: TEXT
   - Index: idx_alert_time (alert_id, triggered_at DESC)

9. **scraper_runs table** (Scraper execution history):
   - id: BIGSERIAL PRIMARY KEY
   - started_at: TIMESTAMP NOT NULL
   - completed_at: TIMESTAMP NULL
   - status: VARCHAR(10) CHECK IN ('running', 'completed', 'failed')
   - estados_processed: INTEGER DEFAULT 0
   - municipios_processed: INTEGER DEFAULT 0
   - stations_found: INTEGER DEFAULT 0
   - price_changes_detected: INTEGER DEFAULT 0
   - errors: JSONB

10. **api_tokens table** (Service authentication):

- id: UUID PRIMARY KEY
- user_id: UUID (nullable, FK to users)
- name: VARCHAR(255) NOT NULL
- token: VARCHAR(80) UNIQUE NOT NULL
- abilities: JSONB
- last_used_at: TIMESTAMP NULL
- expires_at: TIMESTAMP NULL
- Index: idx_token

**CRITICAL PostgreSQL Syntax Notes:**

- Use SERIAL or BIGSERIAL instead of AUTO_INCREMENT
- Use CHECK constraints instead of ENUM: `fuel_type VARCHAR(10) CHECK (fuel_type IN ('regular', 'premium', 'diesel'))`
- For updated_at triggers, create a function and trigger (Laravel handles this automatically)
- Use gen_random_uuid() for UUID generation or let Laravel handle it with Str::uuid()

### Laravel Migration Patterns

[Source: architecture/backend-architecture.md]

Laravel migrations should be created in apps/api/database/migrations/ with:

```php
Schema::create('table_name', function (Blueprint $table) {
    // column definitions
});
```

For PostgreSQL-specific features:

- Use `$table->uuid('id')->primary()` for UUID fields
- Use `$table->jsonb('field')` for JSONB columns (better performance than JSON)
- Use `DB::statement()` for raw PostgreSQL commands when needed
- Example migration for fuel_type with CHECK constraint:

```php
Schema::create('price_changes', function (Blueprint $table) {
    $table->bigIncrements('id'); // Uses BIGSERIAL in PostgreSQL
    $table->string('fuel_type', 10);
    // ... other columns
});
DB::statement("ALTER TABLE price_changes ADD CONSTRAINT check_fuel_type CHECK (fuel_type IN ('regular', 'premium', 'diesel'))");
```

### Fuel Type Mapping Logic

[Source: architecture/external-apis.md#fuel-type-mapping-logic]

The government API SubProducto field needs normalization:

**Regular Mapping:**

- "Regular (con un índice de octano ([RON+MON]/2) mínimo de 87)" → 'regular'
- "Regular (con contenido menor a 92 octanos)" → 'regular'

**Premium Mapping:**

- "Premium (con un índice de octano ([RON+MON]/2) mínimo de 91)" → 'premium'
- "Premium (con contenido mínimo de 92 octanos)" → 'premium'

**Diesel Mapping:**

- "Diésel Automotriz [contenido mayor de azufre...]" → 'diesel'
- "Diésel" → 'diesel'

Store the normalized value in fuel_type while preserving original in subproducto field.

### Government API Integration

[Source: architecture/external-apis.md#government-pricing-api]

For initial data seeding (AC 6):

- Catalog API Base: `https://api-catalogo.cne.gob.mx/api/utiles`
- States endpoint: `/entidadesfederativas` (returns 32 states)
- Municipalities endpoint: `/municipios?EntidadFederativaId={id}`

Each state has an EntidadFederativaId that must match our entidades.id field.

### TypeScript Type Definitions

[Source: architecture/data-models.md]

The following TypeScript interfaces were defined in Story 1.1 and should align with the database schema:

- Station interface with numero as string primary key
- PriceChange interface with fuel_type as union type
- User interface with UUID id
- Alert interface with conditions as JSON

### Migration File Locations

[Source: architecture/unified-project-structure.md#lines-42-44]

All migrations should be created in:

```
apps/api/database/migrations/
```

Seeders should be created in:

```
apps/api/database/seeders/
```

### Critical Implementation Notes

1. **Complete Schema Implementation**: This story creates ALL database tables defined in the architecture to ensure consistency and proper foreign key relationships from the start.

2. **Change-Only Storage Pattern**: The price_changes table only stores records when a price actually changes, not daily snapshots. This is critical for storage efficiency.

3. **PostgreSQL Adaptations**:
   - Replace AUTO_INCREMENT with SERIAL/BIGSERIAL (Laravel's increments() handles this)
   - Use CHECK constraints instead of ENUM: `fuel_type VARCHAR(10) CHECK (fuel_type IN ('regular', 'premium', 'diesel'))`
   - Use JSONB instead of JSON for better performance
   - For UUID generation: Let Laravel handle it with `Str::uuid()` or use PostgreSQL's `gen_random_uuid()`

4. **Foreign Key Integrity**: All foreign keys must have proper constraints to maintain referential integrity across all 10 tables.

5. **Initial Data Load**: The LocationSeeder must handle potential API failures with retry logic and should be idempotent.

6. **Table Creation Order**: Create tables in this order to respect foreign key dependencies:
   - First: entidades, users
   - Second: municipios, api_tokens
   - Third: stations, alerts
   - Fourth: price_changes, user_stations, alert_notifications, scraper_runs

## Testing

### Testing Standards

[Source: architecture/testing-strategy.md#backend-tests]

- Create migration tests in apps/api/tests/Feature/
- Test that all tables are created correctly
- Verify foreign key constraints work
- Test the fuel type mapping helper with unit tests in apps/api/tests/Unit/
- Ensure seeders can run without errors
- Test rollback procedures work correctly

### Specific Test Cases

1. Verify all 10 tables created successfully: `php artisan migrate`
2. Test foreign key constraints prevent orphaned records in all relationships
3. Verify CHECK constraints work:
   - price_changes.fuel_type only accepts 'regular', 'premium', 'diesel'
   - users.subscription_tier only accepts 'free', 'basic', 'premium'
   - alerts.type only accepts 'price_change', 'competitor_move', 'market_trend'
4. Test UUID generation for users, alerts, and api_tokens tables
5. Verify JSONB fields accept and query JSON data correctly
6. Test LocationSeeder successfully loads 32 states and their municipalities
7. Verify fuel type mapping handles all known SubProducto variants
8. Test migration rollback works cleanly: `php artisan migrate:rollback`
9. Verify all indexes are created and improve query performance

## Change Log

| Date       | Version | Description                                                           | Author      |
| ---------- | ------- | --------------------------------------------------------------------- | ----------- |
| 2025-08-13 | 1.0     | Initial story creation                                                | BMad Master |
| 2025-08-13 | 1.1     | Fixed PostgreSQL syntax, clarified scope, removed out-of-scope tables | BMad Master |
| 2025-08-13 | 1.2     | Added all tables per architecture - complete schema implementation    | BMad Master |

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Debug Log References

(To be filled by dev agent)

### Completion Notes List

(To be filled by dev agent)

### File List

(To be filled by dev agent)

## QA Results

(To be filled by QA agent)
