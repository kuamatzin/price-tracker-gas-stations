# Story 2.3: Historical Data & Trends API

## Status

Approved

## Story

**As a** pricing analyst,
**I want** to access historical price data and trends,
**so that** I can identify patterns and optimize pricing strategies.

## Acceptance Criteria

1. GET /api/v1/prices/history/{station_id} returns price changes for specified date range (default 7 days)
2. GET /api/v1/trends/station/{id} calculates trend metrics (avg, min, max, volatility) for specified period
3. GET /api/v1/trends/market returns aggregate market trends by geographic area
4. Endpoint supports grouping by day, week, or month with proper aggregation
5. Include percentage changes and comparison to market average in responses
6. Chart-ready data format with proper time series structure for frontend consumption

## Tasks / Subtasks

- [ ] **Task 1: Create HistoryController and TrendController** (AC: 1, 2, 3)
  - [ ] Create HistoryController in app/Http/Controllers/Api/
  - [ ] Create TrendController for trend analysis endpoints
  - [ ] Add routes to routes/api/v1.php
  - [ ] Apply authentication middleware
  - [ ] Set up dependency injection

- [ ] **Task 2: Build HistoricalDataRepository** (AC: 1, 4)
  - [ ] Create repository for historical queries
  - [ ] Implement getStationHistory() with date range
  - [ ] Add support for fuel type filtering
  - [ ] Optimize queries for time series data
  - [ ] Handle sparse data (gaps in price changes)

- [ ] **Task 3: Implement price history endpoint** (AC: 1, 6)
  - [ ] Create validation for date range (max 365 days)
  - [ ] Query price_changes within date range
  - [ ] Fill gaps with previous known prices
  - [ ] Format as time series array
  - [ ] Include metadata (total changes, date range)

- [ ] **Task 4: Create TrendAnalysisService** (AC: 2, 5)
  - [ ] Calculate average price over period
  - [ ] Find min/max prices with timestamps
  - [ ] Calculate price volatility (standard deviation)
  - [ ] Compute percentage change over period
  - [ ] Add moving average calculations

- [ ] **Task 5: Build station trends endpoint** (AC: 2, 5)
  - [ ] Aggregate price data by time period
  - [ ] Calculate trend metrics for each fuel type
  - [ ] Compare to market average
  - [ ] Identify trend direction (rising/falling/stable)
  - [ ] Return confidence scores for trends

- [ ] **Task 6: Implement market trends endpoint** (AC: 3, 4, 5)
  - [ ] Accept geographic filters (entidad/municipio)
  - [ ] Calculate aggregate statistics across stations
  - [ ] Support grouping by day/week/month
  - [ ] Include station count in aggregations
  - [ ] Compare regions against national average

- [ ] **Task 7: Add time series aggregation** (AC: 4, 6)
  - [ ] Implement daily aggregation logic
  - [ ] Create weekly rollup calculations
  - [ ] Build monthly summary generation
  - [ ] Handle partial periods correctly
  - [ ] Ensure consistent timezone handling

- [ ] **Task 8: Create chart-ready formatters** (AC: 6)
  - [ ] Format data for line charts (time series)
  - [ ] Structure data for bar charts (comparisons)
  - [ ] Include proper axis labels and units
  - [ ] Add data point tooltips information
  - [ ] Ensure frontend compatibility (Recharts)

- [ ] **Task 9: Implement caching for expensive calculations** (AC: 2, 3)
  - [ ] Cache trend calculations (1-hour TTL)
  - [ ] Use cache warming for popular queries
  - [ ] Implement cache invalidation on new data
  - [ ] Add cache bypass option
  - [ ] Monitor cache performance

- [ ] **Task 10: Add statistical calculations** (AC: 2, 5)
  - [ ] Calculate standard deviation for volatility
  - [ ] Implement linear regression for trend lines
  - [ ] Add seasonal pattern detection
  - [ ] Compute correlation between stations
  - [ ] Generate predictive indicators

- [ ] **Task 11: Optimize database queries** (AC: 1, 3, 6)
  - [ ] Use window functions for calculations
  - [ ] Implement materialized views for aggregates
  - [ ] Add database functions for common calculations
  - [ ] Create indexes for time-based queries
  - [ ] Monitor query performance

## Dev Notes

### Previous Story Context

[Source: Stories 1.2, 1.4, 2.2]

- Story 1.2: price_changes table with historical data
- Story 1.4: Scraper continuously adding new price data
- Story 2.2: Current pricing endpoints established

### Historical Query Patterns

[Source: architecture/database-schema.md]

**Time Series Query with Gap Filling:**

```sql
WITH date_series AS (
  SELECT generate_series(
    :start_date::timestamp,
    :end_date::timestamp,
    '1 day'::interval
  ) AS date
),
price_data AS (
  SELECT
    date_trunc('day', changed_at) as date,
    fuel_type,
    AVG(price) as avg_price,
    MIN(price) as min_price,
    MAX(price) as max_price,
    COUNT(*) as change_count
  FROM price_changes
  WHERE station_numero = :station_id
    AND changed_at BETWEEN :start_date AND :end_date
  GROUP BY date_trunc('day', changed_at), fuel_type
)
SELECT
  ds.date,
  pd.fuel_type,
  COALESCE(pd.avg_price, LAG(pd.avg_price) OVER (PARTITION BY pd.fuel_type ORDER BY ds.date)) as price,
  pd.min_price,
  pd.max_price,
  COALESCE(pd.change_count, 0) as changes
FROM date_series ds
LEFT JOIN price_data pd ON ds.date = pd.date
ORDER BY ds.date, pd.fuel_type;
```

### Trend Calculations

[Source: AC 2, 5]

**Volatility Calculation:**

```php
// app/Services/TrendAnalysisService.php
public function calculateVolatility(array $prices): float
{
    $mean = array_sum($prices) / count($prices);
    $variance = array_reduce($prices, function ($carry, $price) use ($mean) {
        return $carry + pow($price - $mean, 2);
    }, 0) / count($prices);

    return sqrt($variance); // Standard deviation as volatility measure
}

public function calculateTrend(array $prices): array
{
    $n = count($prices);
    $x = range(0, $n - 1);
    $y = array_values($prices);

    $x_mean = array_sum($x) / $n;
    $y_mean = array_sum($y) / $n;

    $num = 0;
    $den = 0;

    for ($i = 0; $i < $n; $i++) {
        $num += ($x[$i] - $x_mean) * ($y[$i] - $y_mean);
        $den += pow($x[$i] - $x_mean, 2);
    }

    $slope = $den != 0 ? $num / $den : 0;

    return [
        'direction' => $slope > 0.01 ? 'rising' : ($slope < -0.01 ? 'falling' : 'stable'),
        'slope' => $slope,
        'confidence' => $this->calculateR2($x, $y, $slope, $y_mean)
    ];
}
```

### Market Aggregation Queries

[Source: AC 3, 4]

**Market Trends by Geographic Area:**

```sql
SELECT
  e.nombre as entidad,
  m.nombre as municipio,
  fuel_type,
  date_trunc(:period, changed_at) as period,
  AVG(price) as avg_price,
  MIN(price) as min_price,
  MAX(price) as max_price,
  STDDEV(price) as price_stddev,
  COUNT(DISTINCT station_numero) as station_count,
  COUNT(*) as sample_size
FROM price_changes pc
JOIN stations s ON pc.station_numero = s.numero
JOIN entidades e ON s.entidad_id = e.id
JOIN municipios m ON s.municipio_id = m.id
WHERE changed_at >= :start_date
  AND changed_at <= :end_date
  AND (:entidad_id IS NULL OR s.entidad_id = :entidad_id)
  AND (:municipio_id IS NULL OR s.municipio_id = :municipio_id)
GROUP BY e.nombre, m.nombre, fuel_type, period
ORDER BY period, e.nombre, m.nombre, fuel_type;
```

### API Response Formats

[Source: AC 1, 2, 3, 6]

**GET /api/v1/prices/history/{station_id}**

```json
{
  "data": {
    "station": {
      "numero": "12345",
      "nombre": "Pemex Centro"
    },
    "period": {
      "start": "2024-01-06",
      "end": "2024-01-13"
    },
    "series": {
      "regular": [
        {"date": "2024-01-06", "price": 22.45, "change": 0},
        {"date": "2024-01-07", "price": 22.45, "change": 0},
        {"date": "2024-01-08", "price": 22.89, "change": 0.44},
        {"date": "2024-01-09", "price": 22.89, "change": 0}
      ],
      "premium": [...],
      "diesel": [...]
    },
    "summary": {
      "total_changes": 3,
      "avg_change_percent": 1.96
    }
  }
}
```

**GET /api/v1/trends/station/{id}**

```json
{
  "data": {
    "station": {
      "numero": "12345",
      "nombre": "Pemex Centro"
    },
    "period": {
      "start": "2024-01-01",
      "end": "2024-01-13",
      "days": 13
    },
    "trends": {
      "regular": {
        "current": 22.89,
        "avg": 22.67,
        "min": {"price": 22.45, "date": "2024-01-03"},
        "max": {"price": 22.89, "date": "2024-01-08"},
        "volatility": 0.18,
        "trend": "rising",
        "slope": 0.034,
        "change_percent": 2.01,
        "vs_market": {
          "difference": -0.12,
          "percent": -0.52,
          "position": "below"
        }
      },
      "premium": {...},
      "diesel": {...}
    }
  }
}
```

**GET /api/v1/trends/market**

```json
{
  "data": {
    "area": {
      "entidad": "CDMX",
      "municipio": "CuauhtÃ©moc"
    },
    "period": {
      "start": "2024-01-01",
      "end": "2024-01-13",
      "grouping": "daily"
    },
    "trends": [
      {
        "date": "2024-01-13",
        "regular": {
          "avg": 23.01,
          "min": 22.45,
          "max": 23.67,
          "median": 22.98,
          "stddev": 0.34,
          "station_count": 45,
          "vs_national": {
            "difference": 0.12,
            "percent": 0.52
          }
        },
        "premium": {...},
        "diesel": {...}
      }
    ],
    "summary": {
      "period_change": {
        "regular": 1.2,
        "premium": 0.8,
        "diesel": -0.5
      },
      "volatility_index": 0.23
    }
  }
}
```

### Chart-Ready Data Format

[Source: AC 6]

**Time Series for Recharts:**

```javascript
// Format for frontend line chart
const chartData = [
  {
    date: "2024-01-06",
    regular: 22.45,
    premium: 24.12,
    diesel: 23.89,
  },
  {
    date: "2024-01-07",
    regular: 22.45,
    premium: 24.12,
    diesel: 23.89,
  },
  // ... more data points
];

// With annotations for price changes
const annotatedData = [
  {
    date: "2024-01-08",
    regular: 22.89,
    premium: 24.12,
    diesel: 23.89,
    events: [{ type: "price_change", fuel: "regular", change: 0.44 }],
  },
];
```

### Caching Strategy

[Source: AC 2, 3]

```php
// Expensive calculations cached
$cacheKey = "trends:station:{$stationId}:{$startDate}:{$endDate}";
$ttl = 3600; // 1 hour for trend calculations

return Cache::remember($cacheKey, $ttl, function () use ($params) {
    return $this->trendService->calculateStationTrends($params);
});

// Cache warming for popular queries
Artisan::call('cache:warm-trends', [
    '--popular' => true,
    '--period' => '7days'
]);
```

### Performance Considerations

[Source: AC 1, 3]

**Materialized View for Market Aggregates:**

```sql
CREATE MATERIALIZED VIEW market_daily_aggregates AS
SELECT
  date_trunc('day', changed_at) as date,
  s.entidad_id,
  s.municipio_id,
  pc.fuel_type,
  AVG(price) as avg_price,
  MIN(price) as min_price,
  MAX(price) as max_price,
  STDDEV(price) as stddev_price,
  COUNT(DISTINCT pc.station_numero) as station_count
FROM price_changes pc
JOIN stations s ON pc.station_numero = s.numero
GROUP BY date, s.entidad_id, s.municipio_id, pc.fuel_type;

CREATE INDEX idx_market_daily ON market_daily_aggregates(date, entidad_id, municipio_id);

-- Refresh daily after scraper runs
REFRESH MATERIALIZED VIEW market_daily_aggregates;
```

### Request Validation

[Source: Laravel best practices]

```php
// app/Http/Requests/HistoryRequest.php
class HistoryRequest extends FormRequest
{
    public function rules()
    {
        return [
            'start_date' => 'nullable|date|before_or_equal:today',
            'end_date' => 'nullable|date|after_or_equal:start_date',
            'fuel_type' => 'nullable|in:regular,premium,diesel',
            'grouping' => 'nullable|in:hourly,daily,weekly,monthly',
        ];
    }

    protected function prepareForValidation()
    {
        $this->merge([
            'start_date' => $this->start_date ?? now()->subDays(7)->format('Y-m-d'),
            'end_date' => $this->end_date ?? now()->format('Y-m-d'),
            'grouping' => $this->grouping ?? 'daily',
        ]);
    }
}
```

## Testing

### Testing Standards

[Source: architecture/testing-strategy.md]

- Feature tests for all trend endpoints
- Unit tests for statistical calculations
- Performance tests for aggregation queries
- Test cache warming and invalidation

### Specific Test Cases

1. History endpoint returns correct date range
2. Gaps in price data are filled correctly
3. Trend calculations are mathematically accurate
4. Volatility calculation handles edge cases
5. Market aggregations group data correctly
6. Time zone handling is consistent
7. Chart data format is valid for frontend
8. Cache is used for expensive calculations
9. Materialized views update correctly
10. Comparison to market average is accurate
11. Seasonal patterns are detected
12. API responds within acceptable time

## Change Log

| Date       | Version | Description            | Author      |
| ---------- | ------- | ---------------------- | ----------- |
| 2025-08-13 | 1.0     | Initial story creation | BMad Master |

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Debug Log References

(To be filled by dev agent)

### Completion Notes List

(To be filled by dev agent)

### File List

(To be filled by dev agent)

## QA Results

(To be filled by QA agent)
