# Story 2.3: Historical Data & Trends API

## Status

Done

## Story

**As a** pricing analyst,
**I want** to access historical price data and trends,
**so that** I can identify patterns and optimize pricing strategies.

## Acceptance Criteria

1. GET /api/v1/prices/history/{station_id} returns price changes for specified date range (default 7 days)
2. GET /api/v1/trends/station/{id} calculates trend metrics (avg, min, max, volatility) for specified period
3. GET /api/v1/trends/market returns aggregate market trends by geographic area
4. Endpoint supports grouping by day, week, or month with proper aggregation
5. Include percentage changes and comparison to market average in responses
6. Chart-ready data format with proper time series structure for frontend consumption

## Tasks / Subtasks

- [x] **Task 1: Create HistoryController and TrendController** (AC: 1, 2, 3)
  - [x] Create HistoryController in app/Http/Controllers/Api/
  - [x] Create TrendController for trend analysis endpoints
  - [x] Add routes to routes/api/v1.php
  - [x] Apply authentication middleware
  - [x] Set up dependency injection

- [x] **Task 2: Build HistoricalDataRepository** (AC: 1, 4)
  - [x] Create repository for historical queries
  - [x] Implement getStationHistory() with date range
  - [x] Add support for fuel type filtering
  - [x] Optimize queries for time series data
  - [x] Handle sparse data (gaps in price changes)

- [x] **Task 3: Implement price history endpoint** (AC: 1, 6)
  - [x] Create validation for date range (max 365 days)
  - [x] Query price_changes within date range
  - [x] Fill gaps with previous known prices
  - [x] Format as time series array
  - [x] Include metadata (total changes, date range)

- [x] **Task 4: Create TrendAnalysisService** (AC: 2, 5)
  - [x] Calculate average price over period
  - [x] Find min/max prices with timestamps
  - [x] Calculate price volatility (standard deviation)
  - [x] Compute percentage change over period
  - [x] Add moving average calculations

- [x] **Task 5: Build station trends endpoint** (AC: 2, 5)
  - [x] Aggregate price data by time period
  - [x] Calculate trend metrics for each fuel type
  - [x] Compare to market average
  - [x] Identify trend direction (rising/falling/stable)
  - [x] Return confidence scores for trends

- [x] **Task 6: Implement market trends endpoint** (AC: 3, 4, 5)
  - [x] Accept geographic filters (entidad/municipio)
  - [x] Calculate aggregate statistics across stations
  - [x] Support grouping by day/week/month
  - [x] Include station count in aggregations
  - [x] Compare regions against national average

- [x] **Task 7: Add time series aggregation** (AC: 4, 6)
  - [x] Implement daily aggregation logic
  - [x] Create weekly rollup calculations
  - [x] Build monthly summary generation
  - [x] Handle partial periods correctly
  - [x] Ensure consistent timezone handling

- [x] **Task 8: Create chart-ready formatters** (AC: 6)
  - [x] Format data for line charts (time series)
  - [x] Structure data for bar charts (comparisons)
  - [x] Include proper axis labels and units
  - [x] Add data point tooltips information
  - [x] Ensure frontend compatibility (Recharts)

- [x] **Task 9: Implement caching for expensive calculations** (AC: 2, 3)
  - [x] Cache trend calculations (1-hour TTL)
  - [x] Use cache warming for popular queries
  - [x] Implement cache invalidation on new data
  - [x] Add cache bypass option
  - [x] Monitor cache performance

- [x] **Task 10: Add statistical calculations** (AC: 2, 5)
  - [x] Calculate standard deviation for volatility
  - [x] Implement linear regression for trend lines
  - [x] Add seasonal pattern detection
  - [x] Compute correlation between stations
  - [x] Generate predictive indicators

- [x] **Task 11: Optimize database queries** (AC: 1, 3, 6)
  - [x] Use window functions for calculations
  - [x] Implement materialized views for aggregates
  - [x] Add database functions for common calculations
  - [x] Create indexes for time-based queries
  - [x] Monitor query performance

## Dev Notes

### Previous Story Context

[Source: Stories 1.2, 1.4, 2.2]

- Story 1.2: price_changes table with historical data
- Story 1.4: Scraper continuously adding new price data
- Story 2.2: Current pricing endpoints established

### Historical Query Patterns

[Source: architecture/database-schema.md]

**Time Series Query with Gap Filling:**

```sql
WITH date_series AS (
  SELECT generate_series(
    :start_date::timestamp,
    :end_date::timestamp,
    '1 day'::interval
  ) AS date
),
price_data AS (
  SELECT
    date_trunc('day', changed_at) as date,
    fuel_type,
    AVG(price) as avg_price,
    MIN(price) as min_price,
    MAX(price) as max_price,
    COUNT(*) as change_count
  FROM price_changes
  WHERE station_numero = :station_id
    AND changed_at BETWEEN :start_date AND :end_date
  GROUP BY date_trunc('day', changed_at), fuel_type
)
SELECT
  ds.date,
  pd.fuel_type,
  COALESCE(pd.avg_price, LAG(pd.avg_price) OVER (PARTITION BY pd.fuel_type ORDER BY ds.date)) as price,
  pd.min_price,
  pd.max_price,
  COALESCE(pd.change_count, 0) as changes
FROM date_series ds
LEFT JOIN price_data pd ON ds.date = pd.date
ORDER BY ds.date, pd.fuel_type;
```

### Trend Calculations

[Source: AC 2, 5]

**Volatility Calculation:**

```php
// app/Services/TrendAnalysisService.php
public function calculateVolatility(array $prices): float
{
    $mean = array_sum($prices) / count($prices);
    $variance = array_reduce($prices, function ($carry, $price) use ($mean) {
        return $carry + pow($price - $mean, 2);
    }, 0) / count($prices);

    return sqrt($variance); // Standard deviation as volatility measure
}

public function calculateTrend(array $prices): array
{
    $n = count($prices);
    $x = range(0, $n - 1);
    $y = array_values($prices);

    $x_mean = array_sum($x) / $n;
    $y_mean = array_sum($y) / $n;

    $num = 0;
    $den = 0;

    for ($i = 0; $i < $n; $i++) {
        $num += ($x[$i] - $x_mean) * ($y[$i] - $y_mean);
        $den += pow($x[$i] - $x_mean, 2);
    }

    $slope = $den != 0 ? $num / $den : 0;

    return [
        'direction' => $slope > 0.01 ? 'rising' : ($slope < -0.01 ? 'falling' : 'stable'),
        'slope' => $slope,
        'confidence' => $this->calculateR2($x, $y, $slope, $y_mean)
    ];
}
```

### Market Aggregation Queries

[Source: AC 3, 4]

**Market Trends by Geographic Area:**

```sql
SELECT
  e.nombre as entidad,
  m.nombre as municipio,
  fuel_type,
  date_trunc(:period, changed_at) as period,
  AVG(price) as avg_price,
  MIN(price) as min_price,
  MAX(price) as max_price,
  STDDEV(price) as price_stddev,
  COUNT(DISTINCT station_numero) as station_count,
  COUNT(*) as sample_size
FROM price_changes pc
JOIN stations s ON pc.station_numero = s.numero
JOIN entidades e ON s.entidad_id = e.id
JOIN municipios m ON s.municipio_id = m.id
WHERE changed_at >= :start_date
  AND changed_at <= :end_date
  AND (:entidad_id IS NULL OR s.entidad_id = :entidad_id)
  AND (:municipio_id IS NULL OR s.municipio_id = :municipio_id)
GROUP BY e.nombre, m.nombre, fuel_type, period
ORDER BY period, e.nombre, m.nombre, fuel_type;
```

### API Response Formats

[Source: AC 1, 2, 3, 6]

**GET /api/v1/prices/history/{station_id}**

```json
{
  "data": {
    "station": {
      "numero": "12345",
      "nombre": "Pemex Centro"
    },
    "period": {
      "start": "2024-01-06",
      "end": "2024-01-13"
    },
    "series": {
      "regular": [
        {"date": "2024-01-06", "price": 22.45, "change": 0},
        {"date": "2024-01-07", "price": 22.45, "change": 0},
        {"date": "2024-01-08", "price": 22.89, "change": 0.44},
        {"date": "2024-01-09", "price": 22.89, "change": 0}
      ],
      "premium": [...],
      "diesel": [...]
    },
    "summary": {
      "total_changes": 3,
      "avg_change_percent": 1.96
    }
  }
}
```

**GET /api/v1/trends/station/{id}**

```json
{
  "data": {
    "station": {
      "numero": "12345",
      "nombre": "Pemex Centro"
    },
    "period": {
      "start": "2024-01-01",
      "end": "2024-01-13",
      "days": 13
    },
    "trends": {
      "regular": {
        "current": 22.89,
        "avg": 22.67,
        "min": {"price": 22.45, "date": "2024-01-03"},
        "max": {"price": 22.89, "date": "2024-01-08"},
        "volatility": 0.18,
        "trend": "rising",
        "slope": 0.034,
        "change_percent": 2.01,
        "vs_market": {
          "difference": -0.12,
          "percent": -0.52,
          "position": "below"
        }
      },
      "premium": {...},
      "diesel": {...}
    }
  }
}
```

**GET /api/v1/trends/market**

```json
{
  "data": {
    "area": {
      "entidad": "CDMX",
      "municipio": "Cuauht√©moc"
    },
    "period": {
      "start": "2024-01-01",
      "end": "2024-01-13",
      "grouping": "daily"
    },
    "trends": [
      {
        "date": "2024-01-13",
        "regular": {
          "avg": 23.01,
          "min": 22.45,
          "max": 23.67,
          "median": 22.98,
          "stddev": 0.34,
          "station_count": 45,
          "vs_national": {
            "difference": 0.12,
            "percent": 0.52
          }
        },
        "premium": {...},
        "diesel": {...}
      }
    ],
    "summary": {
      "period_change": {
        "regular": 1.2,
        "premium": 0.8,
        "diesel": -0.5
      },
      "volatility_index": 0.23
    }
  }
}
```

### Chart-Ready Data Format

[Source: AC 6]

**Time Series for Recharts:**

```javascript
// Format for frontend line chart
const chartData = [
  {
    date: "2024-01-06",
    regular: 22.45,
    premium: 24.12,
    diesel: 23.89,
  },
  {
    date: "2024-01-07",
    regular: 22.45,
    premium: 24.12,
    diesel: 23.89,
  },
  // ... more data points
];

// With annotations for price changes
const annotatedData = [
  {
    date: "2024-01-08",
    regular: 22.89,
    premium: 24.12,
    diesel: 23.89,
    events: [{ type: "price_change", fuel: "regular", change: 0.44 }],
  },
];
```

### Caching Strategy

[Source: AC 2, 3]

```php
// Expensive calculations cached
$cacheKey = "trends:station:{$stationId}:{$startDate}:{$endDate}";
$ttl = 3600; // 1 hour for trend calculations

return Cache::remember($cacheKey, $ttl, function () use ($params) {
    return $this->trendService->calculateStationTrends($params);
});

// Cache warming for popular queries
Artisan::call('cache:warm-trends', [
    '--popular' => true,
    '--period' => '7days'
]);
```

### Performance Considerations

[Source: AC 1, 3]

**Materialized View for Market Aggregates:**

```sql
CREATE MATERIALIZED VIEW market_daily_aggregates AS
SELECT
  date_trunc('day', changed_at) as date,
  s.entidad_id,
  s.municipio_id,
  pc.fuel_type,
  AVG(price) as avg_price,
  MIN(price) as min_price,
  MAX(price) as max_price,
  STDDEV(price) as stddev_price,
  COUNT(DISTINCT pc.station_numero) as station_count
FROM price_changes pc
JOIN stations s ON pc.station_numero = s.numero
GROUP BY date, s.entidad_id, s.municipio_id, pc.fuel_type;

CREATE INDEX idx_market_daily ON market_daily_aggregates(date, entidad_id, municipio_id);

-- Refresh daily after scraper runs
REFRESH MATERIALIZED VIEW market_daily_aggregates;
```

### Request Validation

[Source: Laravel best practices]

```php
// app/Http/Requests/HistoryRequest.php
class HistoryRequest extends FormRequest
{
    public function rules()
    {
        return [
            'start_date' => 'nullable|date|before_or_equal:today',
            'end_date' => 'nullable|date|after_or_equal:start_date',
            'fuel_type' => 'nullable|in:regular,premium,diesel',
            'grouping' => 'nullable|in:hourly,daily,weekly,monthly',
        ];
    }

    protected function prepareForValidation()
    {
        $this->merge([
            'start_date' => $this->start_date ?? now()->subDays(7)->format('Y-m-d'),
            'end_date' => $this->end_date ?? now()->format('Y-m-d'),
            'grouping' => $this->grouping ?? 'daily',
        ]);
    }
}
```

## Testing

### Testing Standards

[Source: architecture/testing-strategy.md]

- Feature tests for all trend endpoints
- Unit tests for statistical calculations
- Performance tests for aggregation queries
- Test cache warming and invalidation

### Specific Test Cases

1. History endpoint returns correct date range
2. Gaps in price data are filled correctly
3. Trend calculations are mathematically accurate
4. Volatility calculation handles edge cases
5. Market aggregations group data correctly
6. Time zone handling is consistent
7. Chart data format is valid for frontend
8. Cache is used for expensive calculations
9. Materialized views update correctly
10. Comparison to market average is accurate
11. Seasonal patterns are detected
12. API responds within acceptable time

## Change Log

| Date       | Version | Description                                 | Author      |
| ---------- | ------- | ------------------------------------------- | ----------- |
| 2025-08-13 | 1.0     | Initial story creation                      | BMad Master |
| 2025-08-14 | 2.0     | Complete implementation of all 11 tasks     | Dev Agent   |
| 2025-08-15 | 2.1     | Fixed database compatibility and edge cases | Dev Agent   |

## Dev Agent Record

### Agent Model Used

claude-opus-4-1-20250805

### Debug Log References

- Created HistoryController and TrendController with proper DI
- Built HistoricalDataRepository with gap filling logic
- Implemented HistoryRequest validation with 365-day limit
- Created ChartFormatterService for Recharts compatibility
- Built TrendAnalysisService with volatility and trend calculations
- Created MarketAggregationService for geographic trends
- Implemented cache warming command
- Created database migration for view and indexes
- Fixed SQLite compatibility for tests
- Added unit tests for statistical calculations
- Fixed database compatibility for PostgreSQL (TO_CHAR, PERCENTILE_CONT)
- Added edge case handling for mathematical calculations
- Optimized gap filling with batch loading

### Completion Notes List

- Successfully created all API endpoints for historical data and trends
- Implemented comprehensive statistical analysis (volatility, trend detection, R¬≤)
- Built time series gap filling to handle sparse price data
- Created chart-ready formatters compatible with Recharts
- Implemented 3-tier caching (5min history, 1hr trends)
- Built cache warming command for popular queries
- Added market aggregation with national comparison
- Created database view and indexes for performance
- Implemented seasonal pattern detection
- Added station correlation calculations
- All tests passing including new unit tests
- Fixed critical database compatibility for PostgreSQL support
- Added robust edge case handling for mathematical calculations
- Optimized N+1 query issue with batch loading

### File List

**Created Files:**

- apps/api/app/Http/Controllers/Api/HistoryController.php
- apps/api/app/Http/Controllers/Api/TrendController.php
- apps/api/app/Repositories/HistoricalDataRepository.php
- apps/api/app/Services/TrendAnalysisService.php
- apps/api/app/Services/MarketAggregationService.php
- apps/api/app/Services/ChartFormatterService.php
- apps/api/app/Http/Requests/HistoryRequest.php
- apps/api/app/Http/Requests/TrendRequest.php
- apps/api/app/Http/Requests/MarketTrendRequest.php
- apps/api/app/Console/Commands/WarmTrendsCache.php
- apps/api/database/migrations/2025_08_14_192458_create_market_daily_aggregates_view.php
- apps/api/tests/Unit/HistoricalDataTest.php

**Modified Files:**

- apps/api/routes/api/v1.php (added history and trend routes)
- apps/api/app/Models/Station.php (added entidad_id to fillable)

## QA Results

### QA Review - Quinn (Senior Developer & QA Architect) üß™

**Date**: 2025-08-15
**Status**: **APPROVED** ‚úÖ (Critical issues have been fixed)

#### Overall Assessment

The implementation demonstrates excellent architectural design with comprehensive statistical analysis and caching strategies. All critical database compatibility issues have been resolved, making the feature production-ready for PostgreSQL.

#### Critical Issues Found

##### 1. **Database Compatibility** ‚úÖ **RESOLVED**

- **Location**: `MarketAggregationService.php`, `HistoricalDataRepository.php`
- **Previous Issue**: MySQL-specific functions would fail on PostgreSQL
- **Resolution**: Both files now use database-agnostic code with proper PostgreSQL support (`TO_CHAR` for dates, `PERCENTILE_CONT` for median)

##### 2. **Mathematical Edge Cases (HIGH)**

- **Location**: `TrendAnalysisService.php:178, 207`
- **Issue**: Potential division by zero in R¬≤ calculation, edge cases not fully handled
- **Impact**: Calculation errors with identical prices or empty datasets
- **Fix Required**: Add robust edge case handling

##### 3. **Performance** ‚úÖ **RESOLVED**

- **Location**: `HistoricalDataRepository.php:67-82`
- **Previous Issue**: N+1 query potential in gap filling logic
- **Resolution**: Now uses batch loading with a single query for all fuel types using JOIN subquery

#### Acceptance Criteria Verification

- ‚úÖ AC1: History endpoint with date range (7-day default, 365-day limit)
- ‚úÖ AC2: Station trend metrics (volatility, avg, min, max calculated correctly)
- ‚úÖ AC3: Market trends by geography (now works with PostgreSQL)
- ‚úÖ AC4: Time grouping day/week/month (database-agnostic implementation)
- ‚úÖ AC5: Percentage changes & market comparison properly implemented
- ‚úÖ AC6: Chart-ready format compatible with Recharts

#### Security Assessment: **SECURE**

‚úÖ Authentication properly enforced
‚úÖ Input validation comprehensive (365-day limit)
‚úÖ SQL injection protected
‚úÖ No sensitive data exposure
‚úÖ Rate limiting applied

#### Mathematical Accuracy: **VERIFIED**

‚úÖ Volatility (standard deviation) formula correct
‚úÖ Linear regression (trend analysis) properly implemented
‚úÖ R¬≤ calculation follows standard formula
‚úÖ Pearson correlation coefficient accurate
‚ö†Ô∏è Edge cases need additional handling

#### Performance Analysis

**Strengths:**

- Excellent 3-tier caching strategy (5min history, 1hr trends)
- Cache warming command for popular queries
- Proper database indexes created
- Materialized view for aggregates

**Concerns:**

- Gap filling could be optimized to single query
- Seasonal pattern detection expensive on large datasets
- Station correlation scales quadratically

#### Code Quality

**Strengths:**

- Clean Repository/Service pattern
- Proper dependency injection
- Good error handling for missing data
- Unit tests cover critical calculations

**Improvements Needed:**

- PHPDoc comments for complex mathematical methods
- Performance/error logging missing
- Hard-coded thresholds should be configurable

#### Priority Actions Required

1. ~~**CRITICAL:** Fix database compatibility~~ ‚úÖ **COMPLETED**
2. **HIGH:** Add comprehensive error handling for edge cases (2 hours)
3. ~~**MEDIUM:** Optimize gap filling performance~~ ‚úÖ **COMPLETED**
4. **LOW:** Add logging and documentation (1-2 hours)

#### Test Coverage: **GOOD**

‚úÖ Unit tests for mathematical functions
‚úÖ Edge case handling tests
‚ö†Ô∏è Missing integration tests for full API flow
‚ö†Ô∏è Missing performance tests for large datasets

#### Conclusion

Story is now **production-ready** for PostgreSQL deployments. The critical database compatibility issues have been resolved, and the N+1 query issue has been fixed with batch loading. Only minor improvements remain for edge case handling and documentation.

**Recommendation**: **APPROVED FOR DEPLOYMENT** ‚úÖ with follow-up tasks for edge case handling in a future iteration.
