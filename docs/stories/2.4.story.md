# Story 2.4: Competitor Analysis Endpoints

## Status

Draft

## Story

**As a** station manager,
**I want** to compare my prices against local competitors,
**so that** I can maintain competitive positioning.

## Acceptance Criteria

1. GET /api/v1/competitors returns competitor list based on user's station location
2. GET /api/v1/analysis/ranking shows user's price position among competitors (1st cheapest, 2nd, etc.)
3. GET /api/v1/analysis/spread returns price spread analysis (difference from min, max, average)
4. Competitor definition configurable by radius (default 5km) or same municipio
5. Analysis includes separate rankings for each fuel type (Regular, Premium, Diesel)
6. Response includes recommendations like "Your Premium is 3% above market average"

## Tasks / Subtasks

- [ ] **Task 1: Create CompetitorController and AnalysisController** (AC: 1, 2, 3)
  - [ ] Create CompetitorController in app/Http/Controllers/Api/
  - [ ] Create AnalysisController for analysis endpoints
  - [ ] Add routes to routes/api/v1.php
  - [ ] Apply authentication middleware
  - [ ] Inject user context for station identification

- [ ] **Task 2: Build CompetitorService** (AC: 1, 4)
  - [ ] Create service to identify competitors
  - [ ] Implement radius-based competitor detection
  - [ ] Add municipio-based competitor detection
  - [ ] Combine both methods with configuration
  - [ ] Cache competitor lists per station

- [ ] **Task 3: Implement competitors endpoint** (AC: 1, 4)
  - [ ] Get user's station from authenticated context
  - [ ] Accept radius and mode parameters
  - [ ] Query stations within radius using Haversine
  - [ ] Include current prices for all competitors
  - [ ] Exclude user's own station from results

- [ ] **Task 4: Create PriceRankingService** (AC: 2, 5)
  - [ ] Calculate rankings for each fuel type
  - [ ] Handle ties in pricing (same rank)
  - [ ] Compute percentile position
  - [ ] Track rank changes from previous period
  - [ ] Generate position descriptions (cheapest, mid-range, expensive)

- [ ] **Task 5: Build ranking analysis endpoint** (AC: 2, 5)
  - [ ] Get competitors for user's station
  - [ ] Calculate rank for each fuel type
  - [ ] Include total competitors in ranking
  - [ ] Show price difference from rank #1
  - [ ] Add historical rank comparison (vs yesterday)

- [ ] **Task 6: Implement SpreadAnalysisService** (AC: 3, 5)
  - [ ] Calculate min, max, avg, median prices
  - [ ] Compute user's position in spread
  - [ ] Calculate standard deviation
  - [ ] Identify outliers (2+ std devs)
  - [ ] Generate spread visualisation data

- [ ] **Task 7: Create spread analysis endpoint** (AC: 3, 5, 6)
  - [ ] Calculate spread metrics for competitors
  - [ ] Compare user prices to spread
  - [ ] Generate percentage differences
  - [ ] Include quartile analysis
  - [ ] Format for easy visualization

- [ ] **Task 8: Build RecommendationEngine** (AC: 6)
  - [ ] Analyze user's competitive position
  - [ ] Generate pricing recommendations
  - [ ] Consider market trends in recommendations
  - [ ] Prioritize recommendations by impact
  - [ ] Include confidence scores

- [ ] **Task 9: Add recommendation generation** (AC: 6)
  - [ ] Create recommendation templates
  - [ ] Calculate potential revenue impact
  - [ ] Consider competitor reactions
  - [ ] Generate actionable suggestions
  - [ ] Translate to Spanish if needed

- [ ] **Task 10: Implement competitive insights** (AC: 2, 3, 6)
  - [ ] Identify pricing patterns among competitors
  - [ ] Detect price leadership behavior
  - [ ] Find optimal pricing windows
  - [ ] Calculate market share estimates
  - [ ] Generate competitive alerts

- [ ] **Task 11: Add performance optimization** (AC: All)
  - [ ] Cache analysis results (15-minute TTL)
  - [ ] Pre-calculate common analyses
  - [ ] Use database views for complex queries
  - [ ] Implement async processing for heavy calculations
  - [ ] Monitor endpoint performance

## Dev Notes

### Previous Story Context

[Source: Stories 1.2, 2.1, 2.2, 2.3]

- Story 1.2: stations and price_changes tables with location data
- Story 2.1: User authentication with station association
- Story 2.2: Current pricing endpoints with distance calculation
- Story 2.3: Historical trends and analysis services

### Competitor Detection Logic

[Source: AC 1, 4]

**Radius-Based Detection:**

```php
// app/Services/CompetitorService.php
public function getCompetitorsByRadius($station, $radius = 5)
{
    $haversine = "(6371 * acos(cos(radians({$station->lat}))
                  * cos(radians(lat))
                  * cos(radians(lng) - radians({$station->lng}))
                  + sin(radians({$station->lat}))
                  * sin(radians(lat))))";

    return Station::selectRaw("*, {$haversine} AS distance_km")
        ->where('numero', '!=', $station->numero)
        ->whereRaw("{$haversine} < ?", [$radius])
        ->where('is_active', true)
        ->orderBy('distance_km')
        ->get();
}
```

**Municipio-Based Detection:**

```php
public function getCompetitorsByMunicipio($station)
{
    return Station::where('municipio_id', $station->municipio_id)
        ->where('numero', '!=', $station->numero)
        ->where('is_active', true)
        ->get();
}
```

### Ranking Calculation

[Source: AC 2, 5]

**SQL Ranking Query:**

```sql
WITH price_ranks AS (
  SELECT
    s.numero,
    s.nombre,
    pc.fuel_type,
    pc.price,
    RANK() OVER (
      PARTITION BY pc.fuel_type
      ORDER BY pc.price ASC
    ) as price_rank,
    COUNT(*) OVER (PARTITION BY pc.fuel_type) as total_competitors
  FROM stations s
  JOIN (
    SELECT DISTINCT ON (station_numero, fuel_type)
      station_numero,
      fuel_type,
      price
    FROM price_changes
    ORDER BY station_numero, fuel_type, changed_at DESC
  ) pc ON s.numero = pc.station_numero
  WHERE s.numero IN (:competitor_ids)
    OR s.numero = :user_station_id
)
SELECT
  fuel_type,
  price_rank,
  total_competitors,
  price,
  ROUND(100.0 * (price_rank - 1) / (total_competitors - 1), 1) as percentile,
  price - MIN(price) OVER (PARTITION BY fuel_type) as diff_from_min,
  MAX(price) OVER (PARTITION BY fuel_type) - price as diff_to_max
FROM price_ranks
WHERE numero = :user_station_id;
```

### Spread Analysis Calculations

[Source: AC 3, 5]

```php
// app/Services/SpreadAnalysisService.php
public function analyzeSpread($userStation, $competitors, $fuelType)
{
    $prices = $this->collectPrices($competitors, $fuelType);
    $userPrice = $this->getUserPrice($userStation, $fuelType);

    $stats = [
        'min' => min($prices),
        'max' => max($prices),
        'avg' => array_sum($prices) / count($prices),
        'median' => $this->calculateMedian($prices),
        'stddev' => $this->calculateStdDev($prices),
        'user_price' => $userPrice,
    ];

    $stats['spread'] = $stats['max'] - $stats['min'];
    $stats['user_position'] = [
        'from_min' => $userPrice - $stats['min'],
        'from_max' => $stats['max'] - $userPrice,
        'from_avg' => $userPrice - $stats['avg'],
        'from_avg_percent' => round(
            (($userPrice - $stats['avg']) / $stats['avg']) * 100, 2
        ),
    ];

    // Quartile analysis
    sort($prices);
    $stats['quartiles'] = [
        'q1' => $this->percentile($prices, 25),
        'q2' => $this->percentile($prices, 50), // median
        'q3' => $this->percentile($prices, 75),
    ];

    $stats['user_quartile'] = $this->determineQuartile(
        $userPrice,
        $stats['quartiles']
    );

    return $stats;
}
```

### Recommendation Templates

[Source: AC 6]

```php
// app/Services/RecommendationEngine.php
class RecommendationEngine
{
    private $templates = [
        'above_average' => [
            'es' => 'Tu {fuel_type} está {percent}% arriba del promedio del mercado. Considera reducir ${amount} para mejorar competitividad.',
            'en' => 'Your {fuel_type} is {percent}% above market average. Consider reducing by ${amount} to improve competitiveness.',
            'priority' => 'high',
            'impact' => 'revenue'
        ],
        'below_average' => [
            'es' => 'Tu {fuel_type} está {percent}% debajo del promedio. Tienes margen para incrementar ${amount} sin perder competitividad.',
            'en' => 'Your {fuel_type} is {percent}% below average. You have room to increase by ${amount} without losing competitiveness.',
            'priority' => 'medium',
            'impact' => 'margin'
        ],
        'optimal_position' => [
            'es' => 'Tu {fuel_type} está en posición óptima (percentil {percentile}). Mantén el precio actual.',
            'en' => 'Your {fuel_type} is optimally positioned (percentile {percentile}). Maintain current pricing.',
            'priority' => 'low',
            'impact' => 'stable'
        ],
        'outlier_high' => [
            'es' => '⚠️ Tu {fuel_type} es significativamente más caro que la competencia. Revisa urgentemente.',
            'en' => '⚠️ Your {fuel_type} is significantly more expensive than competitors. Urgent review needed.',
            'priority' => 'critical',
            'impact' => 'customer_loss'
        ],
    ];

    public function generateRecommendations($analysis)
    {
        $recommendations = [];

        foreach (['regular', 'premium', 'diesel'] as $fuelType) {
            $spread = $analysis[$fuelType]['spread'];
            $position = $analysis[$fuelType]['user_position'];

            if ($position['from_avg_percent'] > 3) {
                $rec = $this->templates['above_average'];
                $rec['values'] = [
                    'fuel_type' => $fuelType,
                    'percent' => abs($position['from_avg_percent']),
                    'amount' => round(abs($position['from_avg']), 2)
                ];
                $recommendations[] = $rec;
            } elseif ($position['from_avg_percent'] < -3) {
                $rec = $this->templates['below_average'];
                $rec['values'] = [
                    'fuel_type' => $fuelType,
                    'percent' => abs($position['from_avg_percent']),
                    'amount' => round(abs($position['from_avg']), 2)
                ];
                $recommendations[] = $rec;
            }

            // Check for outliers (2+ standard deviations)
            if (abs($position['from_avg']) > (2 * $spread['stddev'])) {
                $rec = $this->templates['outlier_high'];
                $rec['values'] = ['fuel_type' => $fuelType];
                $recommendations[] = $rec;
            }
        }

        // Sort by priority
        usort($recommendations, function($a, $b) {
            $priorities = ['critical' => 0, 'high' => 1, 'medium' => 2, 'low' => 3];
            return $priorities[$a['priority']] - $priorities[$b['priority']];
        });

        return array_slice($recommendations, 0, 5); // Top 5 recommendations
    }
}
```

### API Response Formats

[Source: AC 1, 2, 3, 6]

**GET /api/v1/competitors**

```json
{
  "data": {
    "user_station": {
      "numero": "12345",
      "nombre": "Mi Estación"
    },
    "settings": {
      "mode": "radius",
      "radius_km": 5
    },
    "competitors": [
      {
        "numero": "12346",
        "nombre": "Pemex Norte",
        "brand": "Pemex",
        "distance_km": 1.2,
        "prices": {
          "regular": 22.45,
          "premium": 24.12,
          "diesel": 23.89
        },
        "last_update": "2024-01-13T08:00:00Z"
      }
    ],
    "total_competitors": 8
  }
}
```

**GET /api/v1/analysis/ranking**

```json
{
  "data": {
    "station": {
      "numero": "12345",
      "nombre": "Mi Estación"
    },
    "rankings": {
      "regular": {
        "rank": 3,
        "total": 8,
        "percentile": 37.5,
        "price": 22.89,
        "diff_from_first": 0.44,
        "position": "competitive",
        "trend": "improving",
        "yesterday_rank": 5
      },
      "premium": {
        "rank": 1,
        "total": 8,
        "percentile": 0,
        "price": 24.12,
        "diff_from_first": 0,
        "position": "cheapest",
        "trend": "maintaining"
      },
      "diesel": {
        "rank": 7,
        "total": 8,
        "percentile": 87.5,
        "price": 24.56,
        "diff_from_first": 1.23,
        "position": "expensive",
        "trend": "worsening",
        "yesterday_rank": 6
      }
    },
    "overall_position": "mixed"
  }
}
```

**GET /api/v1/analysis/spread**

```json
{
  "data": {
    "analysis": {
      "regular": {
        "market": {
          "min": 22.45,
          "max": 23.67,
          "avg": 22.98,
          "median": 22.95,
          "spread": 1.22,
          "stddev": 0.34
        },
        "position": {
          "user_price": 22.89,
          "from_min": 0.44,
          "from_max": -0.78,
          "from_avg": -0.09,
          "from_avg_percent": -0.39,
          "quartile": "Q2"
        }
      },
      "premium": {...},
      "diesel": {...}
    },
    "recommendations": [
      {
        "message": "Tu Diesel está 5.2% arriba del promedio del mercado. Considera reducir $1.20 para mejorar competitividad.",
        "priority": "high",
        "fuel_type": "diesel",
        "suggested_price": 23.36,
        "potential_impact": "Increase customer traffic by estimated 15%"
      },
      {
        "message": "Tu Premium está en posición óptima (percentil 25). Mantén el precio actual.",
        "priority": "low",
        "fuel_type": "premium"
      }
    ]
  }
}
```

### Caching Strategy

[Source: AC 11]

```php
// Cache competitor lists
$competitorsCacheKey = "competitors:{$stationId}:{$mode}:{$radius}";
$competitors = Cache::remember($competitorsCacheKey, 900, function() {
    return $this->competitorService->getCompetitors($params);
});

// Cache analysis results
$analysisCacheKey = "analysis:ranking:{$stationId}:" . date('Y-m-d-H');
$ranking = Cache::remember($analysisCacheKey, 900, function() {
    return $this->analysisService->calculateRanking($params);
});
```

### Performance Optimizations

[Source: AC 11]

```sql
-- Materialized view for competitor analysis
CREATE MATERIALIZED VIEW competitor_current_prices AS
SELECT
  s.numero,
  s.nombre,
  s.brand,
  s.lat,
  s.lng,
  s.municipio_id,
  s.entidad_id,
  pc.fuel_type,
  pc.price,
  pc.changed_at
FROM stations s
JOIN LATERAL (
  SELECT DISTINCT ON (fuel_type)
    fuel_type,
    price,
    changed_at
  FROM price_changes
  WHERE station_numero = s.numero
  ORDER BY fuel_type, changed_at DESC
) pc ON true
WHERE s.is_active = true;

CREATE INDEX idx_competitor_prices_location
ON competitor_current_prices(municipio_id, fuel_type);

-- Refresh every 15 minutes
REFRESH MATERIALIZED VIEW CONCURRENTLY competitor_current_prices;
```

## Testing

### Testing Standards

[Source: architecture/testing-strategy.md]

- Feature tests for all analysis endpoints
- Unit tests for calculation services
- Performance tests for complex queries
- Test recommendation generation logic

### Specific Test Cases

1. Competitors list excludes user's own station
2. Radius-based detection works correctly
3. Municipio-based detection works correctly
4. Rankings calculated correctly with ties
5. Percentile calculations are accurate
6. Spread analysis handles edge cases
7. Recommendations generated appropriately
8. Spanish/English translations work
9. Cache invalidation works properly
10. Analysis updates when prices change
11. Historical rank comparison is accurate
12. Outlier detection works correctly

## Change Log

| Date       | Version | Description            | Author      |
| ---------- | ------- | ---------------------- | ----------- |
| 2025-08-13 | 1.0     | Initial story creation | BMad Master |

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Debug Log References

(To be filled by dev agent)

### Completion Notes List

(To be filled by dev agent)

### File List

(To be filled by dev agent)

## QA Results

(To be filled by QA agent)
