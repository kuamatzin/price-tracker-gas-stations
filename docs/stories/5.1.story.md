# Story 5.1: Alert Rules Engine

## Status

Draft

## Story

**As a** multi-station owner,
**I want** to create station-specific alert rules,
**so that** I can receive customized notifications for each of my locations.

## Acceptance Criteria

1. Alert rules are created per station with station_numero reference
2. Rules engine supports conditions based on station-specific price changes, thresholds, and competitor movements
3. Alert types include immediate (Telegram), daily digest per station, and weekly summary
4. Different alert thresholds can be set for each station
5. Rules can combine multiple conditions with AND/OR logic
6. User-specific alert preferences stored and managed through API per station
7. Alert history tracked with station context, delivery status and user acknowledgment
8. Admin interface to monitor alert volume per station and delivery success rates

## Tasks / Subtasks

- [ ] Task 1: Create station-aware alert rules data models and migrations (AC: 1, 4, 6)
  - [ ] Create AlertRule model with station_numero foreign key
  - [ ] Add jsonb conditions field for flexible rule storage
  - [ ] Create AlertHistory model with station_numero reference
  - [ ] Create migrations for alert_rules and alert_histories tables
  - [ ] Add indexes for efficient querying by user_id, station_numero and status
  - [ ] Add unique constraint for rule name per station

- [ ] Task 2: Implement station-aware alert condition evaluator service (AC: 2, 4, 5)
  - [ ] Create AlertEvaluatorService in apps/api/app/Services/
  - [ ] Implement station-specific price change detection
  - [ ] Implement threshold comparison per station
  - [ ] Implement competitor movement detection relative to station
  - [ ] Support AND/OR condition combination logic
  - [ ] Filter evaluations by station_numero

- [ ] Task 3: Build station-aware alert notification system (AC: 3, 7)
  - [ ] Create AlertNotificationService for dispatching alerts
  - [ ] Include station name/numero in all notifications
  - [ ] Implement immediate Telegram notifications with station context
  - [ ] Implement daily digest aggregation per station
  - [ ] Implement weekly summary compilation across all stations
  - [ ] Track delivery status with station_numero reference

- [ ] Task 4: Create station-aware API endpoints for alert management (AC: 1, 6)
  - [ ] POST /api/v1/stations/{numero}/alerts - Create new alert rule for station
  - [ ] GET /api/v1/stations/{numero}/alerts - List station's alert rules
  - [ ] GET /api/v1/alerts - List all user's alert rules across all stations
  - [ ] PUT /api/v1/alerts/{id} - Update alert rule (verify station ownership)
  - [ ] DELETE /api/v1/alerts/{id} - Delete alert rule (verify station ownership)
  - [ ] GET /api/v1/stations/{numero}/alerts/history - Get station's alert history
  - [ ] Add station_numero validation middleware

- [ ] Task 5: Implement station-aware alert processing queue job (AC: 1, 2, 5)
  - [ ] Create ProcessStationAlerts job in apps/api/app/Jobs/
  - [ ] Accept station_numero as parameter
  - [ ] Queue job per station after scraper updates station prices
  - [ ] Evaluate only active rules for the specific station
  - [ ] Dispatch notifications with station context
  - [ ] Record alert history with station_numero reference
  - [ ] Process multiple stations in parallel

- [ ] Task 6: Build station-aware admin monitoring interface (AC: 8)
  - [ ] Create AlertMonitoringController for admin endpoints
  - [ ] Implement metrics aggregation per station
  - [ ] Track delivery success/failure rates by station
  - [ ] Show alert volume heatmap across all stations
  - [ ] Create dashboard component in apps/web/src/pages/admin/
  - [ ] Add station filter for monitoring view
  - [ ] Display top alerting stations

- [ ] Task 7: Write comprehensive tests (AC: 1-8)
  - [ ] Unit tests for station-aware AlertEvaluatorService logic
  - [ ] Feature tests for station-specific alert API endpoints
  - [ ] Test multi-station alert rule management
  - [ ] Integration tests for station-specific notification delivery
  - [ ] Queue job tests for per-station alert processing
  - [ ] Test station access validation
  - [ ] Test alert isolation between stations

## Dev Notes

### Data Models

The Alert model already exists in the architecture (data-models.md#alert-model) with the following structure:

- id: uuid - Primary key
- user_id: uuid - Foreign key to User
- name: string - User-defined alert name
- type: enum - 'price_change', 'competitor_move', 'market_trend'
- conditions: jsonb - Alert trigger conditions
- is_active: boolean - Whether alert is enabled
- last_triggered_at: timestamp - Last time alert fired

AlertConditions interface includes:

- fuel_types?: FuelType[]
- threshold_percentage?: number
- threshold_amount?: number
- competitor_stations?: string[]
- radius_km?: number
- comparison_type?: "above" | "below" | "any"
  [Source: architecture/data-models.md#alert-model]

### API Integration

Alert endpoints should follow existing patterns:

- Use Laravel Sanctum for authentication
- Follow REST naming conventions with kebab-case
- Use Cache facade with consistent key naming: `alerts:{user_id}:{property}`
- All heavy operations must be queued
  [Source: architecture/coding-standards.md#critical-fullstack-rules]

### File Locations

Based on the project structure:

- Models: apps/api/app/Models/Alert.php, AlertHistory.php
- Services: apps/api/app/Services/AlertEvaluatorService.php, AlertNotificationService.php
- Controllers: apps/api/app/Http/Controllers/Api/AlertController.php
- Jobs: apps/api/app/Jobs/ProcessAlerts.php
- Migrations: apps/api/database/migrations/
- Admin UI: apps/web/src/pages/admin/alerts/
  [Source: architecture/unified-project-structure.md]

### Technology Stack

- Backend: Laravel 11.x with PHP 8.3+
- Queue System: Laravel Queues with Redis driver
- Bot Framework: BotMan 2.8+ for Telegram integration
- State Management: Zustand 4.4+ for admin dashboard
- Testing: PHPUnit 10.x for backend, Vitest 1.0+ for frontend
  [Source: architecture/tech-stack.md#technology-stack-table]

### Testing Requirements

- Test file locations:
  - Backend: apps/api/tests/Unit/, apps/api/tests/Feature/
  - Frontend: apps/web/tests/unit/
- Follow testing pyramid: 30% unit, 30% integration, 10% E2E
- Alert API tests should verify validation, auth, and response structure
  [Source: architecture/testing-strategy.md#test-organization]

## Testing

### Testing Standards from Architecture

- Backend tests in apps/api/tests/ using PHPUnit
- Test alert rule CRUD operations in Feature/AlertApiTest.php
- Test evaluator logic in Unit/AlertEvaluatorServiceTest.php
- Test notification delivery in Integration/AlertNotificationTest.php
- Frontend admin components in apps/web/tests/unit/
- Use factories for test data generation
- Mock external services (Telegram) in tests
  [Source: architecture/testing-strategy.md]

## Change Log

| Date       | Version | Description            | Author      |
| ---------- | ------- | ---------------------- | ----------- |
| 2025-08-31 | 1.0     | Initial story creation | BMad Master |

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Debug Log References

(To be filled by dev agent)

### Completion Notes List

(To be filled by dev agent)

### File List

(To be filled by dev agent)

## QA Results

(To be filled by QA agent)
